/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { GeneratedClient } from "../generatedClient";
import {
  ComputeNode as ComputeNodeModel,
  ComputeNodeListNextOptionalParams,
  ComputeNodeListOptionalParams,
  ComputeNodeUser,
  ComputeNodeAddUserOptionalParams,
  ComputeNodeAddUserResponse,
  ComputeNodeDeleteUserOptionalParams,
  ComputeNodeDeleteUserResponse,
  NodeUpdateUserParameter,
  ComputeNodeUpdateUserOptionalParams,
  ComputeNodeUpdateUserResponse,
  ComputeNodeGetOptionalParams,
  ComputeNodeGetResponse,
  ComputeNodeRebootOptionalParams,
  ComputeNodeRebootResponse,
  ComputeNodeReimageOptionalParams,
  ComputeNodeReimageResponse,
  ComputeNodeDisableSchedulingOptionalParams,
  ComputeNodeDisableSchedulingResponse,
  ComputeNodeEnableSchedulingOptionalParams,
  ComputeNodeEnableSchedulingResponse,
  ComputeNodeGetRemoteLoginSettingsOptionalParams,
  ComputeNodeGetRemoteLoginSettingsResponse,
  ComputeNodeGetRemoteDesktopOptionalParams,
  ComputeNodeGetRemoteDesktopResponse,
  UploadBatchServiceLogsConfiguration,
  ComputeNodeUploadBatchServiceLogsOptionalParams,
  ComputeNodeUploadBatchServiceLogsResponse,
  ComputeNodeListResponse,
  ComputeNodeListNextResponse
} from "../models";

/** Class representing a ComputeNode. */
export class ComputeNode {
  private readonly client: GeneratedClient;

  /**
   * Initialize a new instance of the class ComputeNode class.
   * @param client Reference to the service client
   */
  constructor(client: GeneratedClient) {
    this.client = client;
  }

  /**
   * Lists the Compute Nodes in the specified Pool.
   * @param poolId The ID of the Pool from which you want to list Compute Nodes.
   * @param options The options parameters.
   */
  public list(
    poolId: string,
    options?: ComputeNodeListOptionalParams
  ): PagedAsyncIterableIterator<ComputeNodeModel> {
    const iter = this.listPagingAll(poolId, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listPagingPage(poolId, options);
      }
    };
  }

  private async *listPagingPage(
    poolId: string,
    options?: ComputeNodeListOptionalParams
  ): AsyncIterableIterator<ComputeNodeModel[]> {
    let result = await this._list(poolId, options);
    yield result.value || [];
    let continuationToken = result.odataNextLink;
    while (continuationToken) {
      result = await this._listNext(poolId, continuationToken, options);
      continuationToken = result.odataNextLink;
      yield result.value || [];
    }
  }

  private async *listPagingAll(
    poolId: string,
    options?: ComputeNodeListOptionalParams
  ): AsyncIterableIterator<ComputeNodeModel> {
    for await (const page of this.listPagingPage(poolId, options)) {
      yield* page;
    }
  }

  /**
   * You can add a user Account to a Compute Node only when it is in the idle or running state.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the machine on which you want to create a user Account.
   * @param user The user Account to be created.
   * @param options The options parameters.
   */
  addUser(
    poolId: string,
    nodeId: string,
    user: ComputeNodeUser,
    options?: ComputeNodeAddUserOptionalParams
  ): Promise<ComputeNodeAddUserResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      user,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      addUserOperationSpec
    ) as Promise<ComputeNodeAddUserResponse>;
  }

  /**
   * You can delete a user Account to a Compute Node only when it is in the idle or running state.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the machine on which you want to delete a user Account.
   * @param userName The name of the user Account to delete.
   * @param options The options parameters.
   */
  deleteUser(
    poolId: string,
    nodeId: string,
    userName: string,
    options?: ComputeNodeDeleteUserOptionalParams
  ): Promise<ComputeNodeDeleteUserResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      userName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      deleteUserOperationSpec
    ) as Promise<ComputeNodeDeleteUserResponse>;
  }

  /**
   * This operation replaces of all the updatable properties of the Account. For example, if the
   * expiryTime element is not specified, the current value is replaced with the default value, not left
   * unmodified. You can update a user Account on a Compute Node only when it is in the idle or running
   * state.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the machine on which you want to update a user Account.
   * @param userName The name of the user Account to update.
   * @param nodeUpdateUserParameter The parameters for the request.
   * @param options The options parameters.
   */
  updateUser(
    poolId: string,
    nodeId: string,
    userName: string,
    nodeUpdateUserParameter: NodeUpdateUserParameter,
    options?: ComputeNodeUpdateUserOptionalParams
  ): Promise<ComputeNodeUpdateUserResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      userName,
      nodeUpdateUserParameter,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      updateUserOperationSpec
    ) as Promise<ComputeNodeUpdateUserResponse>;
  }

  /**
   * Gets information about the specified Compute Node.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node that you want to get information about.
   * @param options The options parameters.
   */
  get(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeGetOptionalParams
  ): Promise<ComputeNodeGetResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getOperationSpec
    ) as Promise<ComputeNodeGetResponse>;
  }

  /**
   * You can restart a Compute Node only if it is in an idle or running state.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node that you want to restart.
   * @param options The options parameters.
   */
  reboot(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeRebootOptionalParams
  ): Promise<ComputeNodeRebootResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      rebootOperationSpec
    ) as Promise<ComputeNodeRebootResponse>;
  }

  /**
   * You can reinstall the operating system on a Compute Node only if it is in an idle or running state.
   * This API can be invoked only on Pools created with the cloud service configuration property.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node that you want to restart.
   * @param options The options parameters.
   */
  reimage(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeReimageOptionalParams
  ): Promise<ComputeNodeReimageResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      reimageOperationSpec
    ) as Promise<ComputeNodeReimageResponse>;
  }

  /**
   * You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node on which you want to disable Task scheduling.
   * @param options The options parameters.
   */
  disableScheduling(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeDisableSchedulingOptionalParams
  ): Promise<ComputeNodeDisableSchedulingResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      disableSchedulingOperationSpec
    ) as Promise<ComputeNodeDisableSchedulingResponse>;
  }

  /**
   * You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node on which you want to enable Task scheduling.
   * @param options The options parameters.
   */
  enableScheduling(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeEnableSchedulingOptionalParams
  ): Promise<ComputeNodeEnableSchedulingResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      enableSchedulingOperationSpec
    ) as Promise<ComputeNodeEnableSchedulingResponse>;
  }

  /**
   * Before you can remotely login to a Compute Node using the remote login settings, you must create a
   * user Account on the Compute Node. This API can be invoked only on Pools created with the virtual
   * machine configuration property. For Pools created with a cloud service configuration, see the
   * GetRemoteDesktop API.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node for which to obtain the remote login settings.
   * @param options The options parameters.
   */
  getRemoteLoginSettings(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeGetRemoteLoginSettingsOptionalParams
  ): Promise<ComputeNodeGetRemoteLoginSettingsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getRemoteLoginSettingsOperationSpec
    ) as Promise<ComputeNodeGetRemoteLoginSettingsResponse>;
  }

  /**
   * Before you can access a Compute Node by using the RDP file, you must create a user Account on the
   * Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For
   * Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node for which you want to get the Remote Desktop Protocol file.
   * @param options The options parameters.
   */
  getRemoteDesktop(
    poolId: string,
    nodeId: string,
    options?: ComputeNodeGetRemoteDesktopOptionalParams
  ): Promise<ComputeNodeGetRemoteDesktopResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getRemoteDesktopOperationSpec
    ) as Promise<ComputeNodeGetRemoteDesktopResponse>;
  }

  /**
   * This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if
   * you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log
   * files should be shared with Azure support to aid in debugging issues with the Batch service.
   * @param poolId The ID of the Pool that contains the Compute Node.
   * @param nodeId The ID of the Compute Node from which you want to upload the Azure Batch service log
   *               files.
   * @param uploadBatchServiceLogsConfiguration The Azure Batch service log files upload configuration.
   * @param options The options parameters.
   */
  uploadBatchServiceLogs(
    poolId: string,
    nodeId: string,
    uploadBatchServiceLogsConfiguration: UploadBatchServiceLogsConfiguration,
    options?: ComputeNodeUploadBatchServiceLogsOptionalParams
  ): Promise<ComputeNodeUploadBatchServiceLogsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nodeId,
      uploadBatchServiceLogsConfiguration,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      uploadBatchServiceLogsOperationSpec
    ) as Promise<ComputeNodeUploadBatchServiceLogsResponse>;
  }

  /**
   * Lists the Compute Nodes in the specified Pool.
   * @param poolId The ID of the Pool from which you want to list Compute Nodes.
   * @param options The options parameters.
   */
  private _list(
    poolId: string,
    options?: ComputeNodeListOptionalParams
  ): Promise<ComputeNodeListResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listOperationSpec
    ) as Promise<ComputeNodeListResponse>;
  }

  /**
   * ListNext
   * @param poolId The ID of the Pool from which you want to list Compute Nodes.
   * @param nextLink The nextLink from the previous successful call to the List method.
   * @param options The options parameters.
   */
  private _listNext(
    poolId: string,
    nextLink: string,
    options?: ComputeNodeListNextOptionalParams
  ): Promise<ComputeNodeListNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      poolId,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listNextOperationSpec
    ) as Promise<ComputeNodeListNextResponse>;
  }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const addUserOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/users",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.ComputeNodeAddUserHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.user,
  queryParameters: [Parameters.apiVersion, Parameters.timeout64],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId64,
    Parameters.returnClientRequestId64,
    Parameters.ocpDate64
  ],
  mediaType: "json",
  serializer
};
const deleteUserOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/users/{userName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.ComputeNodeDeleteUserHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout65],
  urlParameters: [
    Parameters.batchUrl,
    Parameters.poolId,
    Parameters.nodeId,
    Parameters.userName
  ],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId65,
    Parameters.returnClientRequestId65,
    Parameters.ocpDate65
  ],
  serializer
};
const updateUserOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/users/{userName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.ComputeNodeUpdateUserHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.nodeUpdateUserParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout66],
  urlParameters: [
    Parameters.batchUrl,
    Parameters.poolId,
    Parameters.nodeId,
    Parameters.userName
  ],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId66,
    Parameters.returnClientRequestId66,
    Parameters.ocpDate66
  ],
  mediaType: "json",
  serializer
};
const getOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ComputeNode,
      headersMapper: Mappers.ComputeNodeGetHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.select13,
    Parameters.timeout67
  ],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId67,
    Parameters.returnClientRequestId67,
    Parameters.ocpDate67
  ],
  serializer
};
const rebootOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/reboot",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: Mappers.ComputeNodeRebootHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.nodeRebootParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout68],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId68,
    Parameters.returnClientRequestId68,
    Parameters.ocpDate68
  ],
  mediaType: "json",
  serializer
};
const reimageOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/reimage",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: Mappers.ComputeNodeReimageHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.nodeReimageParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout69],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId69,
    Parameters.returnClientRequestId69,
    Parameters.ocpDate69
  ],
  mediaType: "json",
  serializer
};
const disableSchedulingOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/disablescheduling",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.ComputeNodeDisableSchedulingHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.nodeDisableSchedulingParameter,
  queryParameters: [Parameters.apiVersion, Parameters.timeout70],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId70,
    Parameters.returnClientRequestId70,
    Parameters.ocpDate70
  ],
  mediaType: "json",
  serializer
};
const enableSchedulingOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/enablescheduling",
  httpMethod: "POST",
  responses: {
    200: {
      headersMapper: Mappers.ComputeNodeEnableSchedulingHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout71],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId71,
    Parameters.returnClientRequestId71,
    Parameters.ocpDate71
  ],
  serializer
};
const getRemoteLoginSettingsOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/remoteloginsettings",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ComputeNodeGetRemoteLoginSettingsResult,
      headersMapper: Mappers.ComputeNodeGetRemoteLoginSettingsHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout72],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId72,
    Parameters.returnClientRequestId72,
    Parameters.ocpDate72
  ],
  serializer
};
const getRemoteDesktopOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/rdp",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: Mappers.ComputeNodeGetRemoteDesktopHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.timeout73],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept1,
    Parameters.clientRequestId73,
    Parameters.returnClientRequestId73,
    Parameters.ocpDate73
  ],
  serializer
};
const uploadBatchServiceLogsOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes/{nodeId}/uploadbatchservicelogs",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.UploadBatchServiceLogsResult,
      headersMapper: Mappers.ComputeNodeUploadBatchServiceLogsHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  requestBody: Parameters.uploadBatchServiceLogsConfiguration,
  queryParameters: [Parameters.apiVersion, Parameters.timeout74],
  urlParameters: [Parameters.batchUrl, Parameters.poolId, Parameters.nodeId],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.clientRequestId74,
    Parameters.returnClientRequestId74,
    Parameters.ocpDate74
  ],
  mediaType: "json",
  serializer
};
const listOperationSpec: coreHttp.OperationSpec = {
  path: "/pools/{poolId}/nodes",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ComputeNodeListResult,
      headersMapper: Mappers.ComputeNodeListHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter12,
    Parameters.select14,
    Parameters.maxResults13,
    Parameters.timeout75
  ],
  urlParameters: [Parameters.batchUrl, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId75,
    Parameters.returnClientRequestId75,
    Parameters.ocpDate75
  ],
  serializer
};
const listNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ComputeNodeListResult,
      headersMapper: Mappers.ComputeNodeListNextHeaders
    },
    default: {
      bodyMapper: Mappers.BatchError
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter12,
    Parameters.select14,
    Parameters.maxResults13,
    Parameters.timeout75
  ],
  urlParameters: [Parameters.batchUrl, Parameters.nextLink, Parameters.poolId],
  headerParameters: [
    Parameters.accept,
    Parameters.clientRequestId75,
    Parameters.returnClientRequestId75,
    Parameters.ocpDate75
  ],
  serializer
};
